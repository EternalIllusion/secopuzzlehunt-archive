{
  "type": "problem",
  "title": "è§£ç»³å­",
  "extendData": "",
  "contentType": 1,
  "content": "<style>\n    /* ================= å®¹å™¨æ ·å¼ ================= */\n    .knot-game-container {\n        font-family: var(--text-font);\n        background: rgba(var(--accent-bg-rgb), 0.15);\n        border: 2px solid var(--border-color);\n        border-radius: 12px;\n        padding: 20px;\n        color: var(--body-text-color);\n        text-align: center;\n        position: relative;\n        min-height: 600px;\n        display: flex;\n        flex-direction: column;\n        user-select: none;\n        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);\n        backdrop-filter: blur(5px);\n    }\n\n    /* ================= ç”»å¸ƒåŒºåŸŸ ================= */\n    .knot-canvas-wrapper {\n        position: relative;\n        flex: 1;\n        width: 100%;\n        min-height: 500px;\n        overflow: hidden;\n        border: 2px solid var(--primary-green);\n        border-radius: 10px;\n        \n        /* æ·±è‰²èƒŒæ™¯ï¼Œç¡®ä¿ç™½çº¿å’Œå½©è‰²èŠ‚ç‚¹æ¸…æ™°å¯è§ */\n        background: rgba(20, 20, 20, 0.9); \n        box-shadow: inset 0 0 20px rgba(0,0,0,0.8);\n        \n        cursor: grab;\n        touch-action: none;\n        transition: border-color 0.3s ease;\n    }\n\n    /* å½“å…³å¡å®Œæˆæ—¶ï¼Œè¾¹æ¡†å˜ç»¿ä»¥ç¤ºåº†ç¥ */\n    .knot-canvas-wrapper.solved-state {\n        border-color: var(--mint-green);\n        box-shadow: 0 0 20px rgba(var(--mint-green), 0.2);\n    }\n\n    .knot-canvas-wrapper:active {\n        cursor: grabbing;\n    }\n\n    canvas {\n        display: block;\n        width: 100%;\n        height: 100%;\n    }\n\n    /* ================= UI æ§ä»¶ ================= */\n    .level-selector {\n        display: flex;\n        justify-content: center;\n        gap: 10px;\n        margin-bottom: 20px;\n        flex-wrap: wrap;\n    }\n\n    .level-btn {\n        width: 44px;\n        height: 44px;\n        border-radius: 50%;\n        border: 2px solid var(--border-color);\n        background: rgba(var(--accent-bg-rgb), 0.3);\n        color: var(--accent-green);\n        font-family: var(--input-font);\n        font-weight: bold;\n        font-size: 1.1rem;\n        cursor: pointer;\n        transition: all 0.2s;\n        display: flex; align-items: center; justify-content: center;\n        box-shadow: 0 4px 8px rgba(0,0,0,0.2);\n    }\n\n    .level-btn:hover:not(:disabled) {\n        transform: translateY(-2px) scale(1.1);\n        background: var(--btn-hover-color);\n        color: var(--white-color);\n        border-color: var(--light-flair-rgb);\n    }\n\n    .level-btn.active {\n        background: var(--primary-green);\n        color: var(--white-color);\n        border-color: var(--white-color);\n        transform: scale(1.15);\n        box-shadow: 0 0 15px var(--glow-color);\n    }\n\n    .level-btn.solved {\n        background: var(--dark-green);\n        border-color: var(--secondary-green);\n        color: var(--mint-green);\n    }\n    \n    .level-btn:disabled {\n        opacity: 0.3;\n        cursor: not-allowed;\n        background: #111;\n        border-color: #333;\n    }\n\n    .status-bar {\n        display: flex;\n        justify-content: space-between;\n        align-items: center;\n        padding: 12px 24px;\n        background: rgba(var(--dark-accent-rgb), 0.6);\n        border-left: 4px solid var(--accent-green);\n        border-radius: 8px;\n        margin-bottom: 15px;\n    }\n\n    #levelTitle {\n        font-family: var(--accent-font);\n        color: var(--accent-green);\n        font-weight: 700;\n        font-size: 1.2rem;\n    }\n\n    .status-text {\n        font-family: var(--input-font);\n        font-size: 1.1rem;\n        font-weight: bold;\n        color: var(--subtle-text-color);\n    }\n\n    .status-success {\n        color: var(--mint-green) !important; \n        text-shadow: 0 0 10px var(--glow-color);\n    }\n\n    .controls {\n        margin-top: 15px;\n        display: flex;\n        justify-content: center;\n        gap: 15px;\n    }\n\n    .btn-game {\n        display: inline-flex;\n        align-items: center;\n        justify-content: center;\n        padding: 10px 24px;\n        border-radius: 25px;\n        background: var(--btn-bg-color);\n        color: var(--btn-text-color);\n        border: none;\n        cursor: pointer;\n        font-family: var(--btn-font);\n        font-weight: 600;\n        transition: all 0.3s ease;\n    }\n    .btn-game:hover {\n        background: var(--btn-hover-color);\n        box-shadow: 0 0 15px var(--glow-color);\n    }\n\n    #final-victory {\n        display: none;\n        margin-top: 20px;\n        padding: 20px;\n        background: rgba(var(--secondary-green), 0.3);\n        border: 2px solid var(--primary-green);\n        border-radius: 10px;\n        animation: fadeIn 1s;\n        color: var(--white-color);\n    }\n    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }\n\n    .zoom-controls {\n        position: absolute;\n        bottom: 15px; right: 15px;\n        display: flex; flex-direction: column; gap: 8px;\n    }\n    .zoom-btn {\n        width: 36px; height: 36px;\n        background: rgba(255,255,255,0.1);\n        color: white; \n        border: 1px solid rgba(255,255,255,0.3);\n        border-radius: 6px; \n        cursor: pointer; font-size: 1.2rem;\n        transition: all 0.2s;\n    }\n    .zoom-btn:hover { background: rgba(255,255,255,0.3); }\n</style>\n\n<div class=\"knot-game-container\">\n    <div class=\"level-selector\" id=\"levelSelector\"></div>\n\n    <div class=\"status-bar\">\n        <span id=\"levelTitle\">å…³å¡ 1</span>\n        <div id=\"gameStatus\" class=\"status-text\">åŠ è½½ä¸­...</div>\n    </div>\n\n    <div class=\"knot-canvas-wrapper\" id=\"canvasWrapper\">\n        <canvas id=\"gameCanvas\"></canvas>\n        <div class=\"zoom-controls\">\n            <button class=\"zoom-btn\" onclick=\"game.zoomIn()\">+</button>\n            <button class=\"zoom-btn\" onclick=\"game.resetView()\">âŒ‚</button>\n            <button class=\"zoom-btn\" onclick=\"game.zoomOut()\">-</button>\n        </div>\n    </div>\n\n    <div class=\"controls\">\n        <button class=\"btn-game\" onclick=\"game.resetLevelPositions()\">é‡ç½®æœ¬å…³å¸ƒå±€</button>\n    </div>\n\n    <div id=\"final-victory\">\n        <h2>ğŸ‰ æ­å–œï¼ä½ å·²è§£å¼€æ‰€æœ‰ç»³ç»“ï¼</h2>\n        <p>æ‰€æœ‰å…³å¡å‡å·²é€šè¿‡ï¼Œä½ çš„è€å¿ƒä»¤äººé’¦ä½©ã€‚</p>\n    </div>\n</div>\n\n<script>\ndocument.addEventListener('DOMContentLoaded', () => {\n    // è·¯å¾„é…ç½®\n    const LEVEL_URLS = [\n        \"{% static 'puzzles/knot/levels/1.json' %}\",\n        \"{% static 'puzzles/knot/levels/2.json' %}\",\n        \"{% static 'puzzles/knot/levels/3.json' %}\",\n        \"{% static 'puzzles/knot/levels/4.json' %}\",\n        \"{% static 'puzzles/knot/levels/5.json' %}\",\n        \"{% static 'puzzles/knot/levels/6.json' %}\",\n        \"{% static 'puzzles/knot/levels/7.json' %}\"\n    ];\n    \n    const TOTAL_LEVELS = LEVEL_URLS.length;\n    const STORAGE_KEY = 'knot_game_progress_v4'; // å‡çº§ç‰ˆæœ¬å·\n\n    // é¢œè‰²é…ç½®\n    const LINE_CONFIG = {\n        normal: '#FFFFFF', // ç™½çº¿\n        error: '#FF5252'   // çº¢çº¿ (äº¤å‰)\n    };\n\n    class KnotGame {\n        constructor() {\n            this.canvas = document.getElementById('gameCanvas');\n            this.ctx = this.canvas.getContext('2d');\n            this.wrapper = document.getElementById('canvasWrapper');\n            this.statusEl = document.getElementById('gameStatus');\n            this.levelTitleEl = document.getElementById('levelTitle');\n            this.finalVictoryEl = document.getElementById('final-victory');\n            \n            this.nodes = [];\n            this.edges = [];\n            \n            this.scale = 1;\n            this.translateX = 0;\n            this.translateY = 0;\n            this.isDraggingNode = false;\n            this.draggedNode = null;\n            this.isPanning = false;\n            this.panStart = {x: 0, y: 0};\n            \n            this.currentLevelIndex = 0;\n            this.progress = this.loadProgress(); \n            \n            this.initListeners();\n            this.renderUI();\n            \n            let startLevel = Math.min(this.progress.unlockedLevel, TOTAL_LEVELS - 1);\n            this.loadLevel(startLevel);\n        }\n\n        loadProgress() {\n            const saved = localStorage.getItem(STORAGE_KEY);\n            if (saved) return JSON.parse(saved);\n            return {\n                unlockedLevel: 0,\n                levelStates: Array(TOTAL_LEVELS).fill(null).map(() => ({\n                    solved: false, positions: null\n                }))\n            };\n        }\n\n        saveProgress() {\n            if (this.nodes.length > 0) {\n                this.progress.levelStates[this.currentLevelIndex].positions = this.nodes.map(n => ({x: n.x, y: n.y}));\n            }\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(this.progress));\n        }\n\n        async loadLevel(index) {\n            if (index > this.progress.unlockedLevel) return;\n            \n            this.currentLevelIndex = index;\n            this.statusEl.innerText = \"åŠ è½½ä¸­...\";\n            this.levelTitleEl.innerText = `å…³å¡ ${index + 1}`;\n            this.renderUI();\n\n            try {\n                const response = await fetch(LEVEL_URLS[index]);\n                if (!response.ok) throw new Error(`HTTP ${response.status}`);\n                const data = await response.json();\n                \n                this.resetView();\n                this.nodes = [];\n                this.edges = [];\n\n                const savedState = this.progress.levelStates[index];\n                const useSaved = savedState.positions && savedState.positions.length === data.nodes.length;\n\n                data.nodes.forEach((n, i) => {\n                    let x, y;\n                    if (useSaved) {\n                        x = savedState.positions[i].x;\n                        y = savedState.positions[i].y;\n                    } else {\n                        x = n.x < 2 ? n.x * this.canvas.clientWidth : n.x;\n                        y = n.y < 2 ? n.y * this.canvas.clientHeight : n.y;\n                        if (x === 0 && y === 0) { x = 100 + i * 50; y = 100 + i * 20; }\n                    }\n                    \n                    this.nodes.push({\n                        id: i,\n                        x: x,\n                        y: y,\n                        radius: 12,\n                        // ã€å…³é”®ã€‘å§‹ç»ˆä½¿ç”¨é…ç½®çš„é¢œè‰²\n                        color: n.color || '#2196f3', \n                        text: n.textDisplay || (n.text ? n.text.substring(0,1) : '')\n                    });\n                });\n\n                this.edges = data.edges;\n                this.draw();\n                this.checkWinCondition(true);\n\n            } catch (e) {\n                console.error(e);\n                this.statusEl.innerText = \"å…³å¡æ–‡ä»¶åŠ è½½å¤±è´¥\";\n            }\n        }\n        resetLevelPositions() {\n            if (!confirm('ç¡®å®šé‡ç½®æœ¬å…³å¸ƒå±€å—ï¼Ÿ')) return;\n            this.progress.levelStates[this.currentLevelIndex].positions = null;\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(this.progress));\n            this.loadLevel(this.currentLevelIndex);\n        }\n\n        handleInput(x, y, type) {\n            const pos = this.screenToCanvas(x, y);\n            \n            if (type === 'start') {\n                const clickedNode = this.nodes.find(n => {\n                    const dx = pos.x - n.x;\n                    const dy = pos.y - n.y;\n                    return Math.sqrt(dx*dx + dy*dy) <= n.radius + 10;\n                });\n\n                if (clickedNode) {\n                    this.isDraggingNode = true;\n                    this.draggedNode = clickedNode;\n                } else {\n                    this.isPanning = true;\n                    this.panStart = { x: x - this.translateX, y: y - this.translateY };\n                    this.wrapper.style.cursor = 'grabbing';\n                }\n            } else if (type === 'move') {\n                if (this.isDraggingNode && this.draggedNode) {\n                    this.draggedNode.x = pos.x;\n                    this.draggedNode.y = pos.y;\n                    this.draw();\n                } else if (this.isPanning) {\n                    this.translateX = x - this.panStart.x;\n                    this.translateY = y - this.panStart.y;\n                    this.draw();\n                }\n            } else if (type === 'end') {\n                if (this.isDraggingNode) {\n                    this.checkWinCondition();\n                    this.saveProgress();\n                }\n                this.isDraggingNode = false;\n                this.draggedNode = null;\n                this.isPanning = false;\n                this.wrapper.style.cursor = 'grab';\n            }\n        }\n\n        lineIntersects(p1, p2, p3, p4) {\n            const det = (p2.x - p1.x) * (p4.y - p3.y) - (p4.x - p3.x) * (p2.y - p1.y);\n            if (det === 0) return false;\n            const lambda = ((p4.y - p3.y) * (p4.x - p1.x) + (p3.x - p4.x) * (p4.y - p1.y)) / det;\n            const gamma = ((p1.y - p2.y) * (p4.x - p1.x) + (p2.x - p1.x) * (p4.y - p1.y)) / det;\n            return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);\n        }\n\n        countIntersections() {\n            let count = 0;\n            const badEdges = new Set();\n            for (let i = 0; i < this.edges.length; i++) {\n                for (let j = i + 1; j < this.edges.length; j++) {\n                    const e1 = this.edges[i];\n                    const e2 = this.edges[j];\n                    if (e1[0]===e2[0] || e1[0]===e2[1] || e1[1]===e2[0] || e1[1]===e2[1]) continue;\n                    \n                    if (this.lineIntersects(\n                        this.nodes[e1[0]], this.nodes[e1[1]],\n                        this.nodes[e2[0]], this.nodes[e2[1]]\n                    )) {\n                        count++;\n                        badEdges.add(i);\n                        badEdges.add(j);\n                    }\n                }\n            }\n            return { count, badEdges };\n        }\n\n        checkWinCondition(init = false) {\n            const { count } = this.countIntersections();\n            const currentState = this.progress.levelStates[this.currentLevelIndex];\n            \n            // é€»è¾‘åˆ¤å®šï¼šæ˜¯å¦è§£å¼€\n            if (count === 0 && !currentState.solved) {\n                currentState.solved = true;\n                if (this.currentLevelIndex < TOTAL_LEVELS - 1) {\n                    if (this.currentLevelIndex === this.progress.unlockedLevel) {\n                        this.progress.unlockedLevel++;\n                    }\n                }\n                this.saveProgress();\n                this.renderUI();\n            }\n\n            // ã€ä¿®æ”¹ã€‘è§†è§‰åé¦ˆï¼šä¸å†ä½¿ç”¨ç°åº¦ï¼Œè€Œæ˜¯é€šè¿‡çŠ¶æ€æ å’Œè¾¹æ¡†åé¦ˆ\n            if (currentState.solved) {\n                this.statusEl.innerText = \"âœ¨ å…³å¡å®Œæˆï¼\";\n                this.statusEl.classList.add('status-success');\n                this.wrapper.classList.add('solved-state'); // æ·»åŠ ç»¿è‰²è¾¹æ¡†\n                \n                if (this.progress.levelStates.every(s => s.solved)) {\n                    this.finalVictoryEl.style.display = 'block';\n                }\n            } else {\n                this.statusEl.innerText = `å‰©ä½™äº¤å‰: ${count}`;\n                this.statusEl.classList.remove('status-success');\n                this.wrapper.classList.remove('solved-state');\n                // ç§»é™¤äº† grayscale-mode ç±»\n            }\n            this.draw();\n        }\n\n        draw() {\n            const dpr = window.devicePixelRatio || 1;\n            const rect = this.wrapper.getBoundingClientRect();\n            if (this.canvas.width !== rect.width * dpr || this.canvas.height !== rect.height * dpr) {\n                this.canvas.width = rect.width * dpr;\n                this.canvas.height = rect.height * dpr;\n                this.ctx.scale(dpr, dpr);\n            }\n\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            this.ctx.save();\n            this.ctx.translate(this.translateX, this.translateY);\n            this.ctx.scale(this.scale, this.scale);\n\n            const { badEdges } = this.countIntersections();\n\n            // ç»˜åˆ¶è¿çº¿\n            this.ctx.lineCap = 'round';\n            this.edges.forEach((edge, idx) => {\n                const n1 = this.nodes[edge[0]];\n                const n2 = this.nodes[edge[1]];\n                \n                this.ctx.beginPath();\n                this.ctx.moveTo(n1.x, n1.y);\n                this.ctx.lineTo(n2.x, n2.y);\n                \n                if (badEdges.has(idx)) {\n                    this.ctx.strokeStyle = LINE_CONFIG.error; // çº¢è‰²äº¤å‰\n                    this.ctx.lineWidth = 4;\n                } else {\n                    this.ctx.strokeStyle = LINE_CONFIG.normal; // ç™½çº¿æ­£å¸¸\n                    this.ctx.lineWidth = 3;\n                }\n                this.ctx.stroke();\n            });\n\n            // ç»˜åˆ¶èŠ‚ç‚¹\n            this.nodes.forEach(node => {\n                this.ctx.beginPath();\n                this.ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);\n                \n                // å§‹ç»ˆæ˜¾ç¤ºå½©è‰²\n                this.ctx.fillStyle = node.color; \n                this.ctx.fill();\n                \n                this.ctx.strokeStyle = 'white';\n                this.ctx.lineWidth = 2;\n                this.ctx.stroke();\n\n                if (node.text) {\n                    this.ctx.fillStyle = 'white';\n                    this.ctx.font = 'bold 12px \"Cascadia Code\", monospace';\n                    this.ctx.textAlign = 'center';\n                    this.ctx.textBaseline = 'middle';\n                    this.ctx.fillText(node.text, node.x, node.y);\n                }\n            });\n\n            this.ctx.restore();\n        }\n\n        renderUI() {\n            const container = document.getElementById('levelSelector');\n            container.innerHTML = '';\n            \n            for (let i = 0; i < TOTAL_LEVELS; i++) {\n                const btn = document.createElement('button');\n                btn.className = 'level-btn';\n                btn.innerText = i + 1;\n                \n                const state = this.progress.levelStates[i];\n                if (state.solved) btn.classList.add('solved');\n                if (i === this.currentLevelIndex) btn.classList.add('active');\n                \n                if (i > this.progress.unlockedLevel) {\n                    btn.disabled = true;\n                } else {\n                    btn.onclick = () => this.loadLevel(i);\n                }\n                container.appendChild(btn);\n            }\n        }\n\n        screenToCanvas(sx, sy) {\n            const rect = this.canvas.getBoundingClientRect();\n            return {\n                x: (sx - rect.left - this.translateX) / this.scale,\n                y: (sy - rect.top - this.translateY) / this.scale\n            };\n        }\n        \n        zoomIn() { this.scale = Math.min(this.scale * 1.2, 3); this.draw(); }\n        zoomOut() { this.scale = Math.max(this.scale / 1.2, 0.5); this.draw(); }\n        resetView() { this.scale = 1; this.translateX = 0; this.translateY = 0; this.draw(); }\n\n        initListeners() {\n            this.wrapper.addEventListener('mousedown', e => this.handleInput(e.clientX, e.clientY, 'start'));\n            window.addEventListener('mousemove', e => this.handleInput(e.clientX, e.clientY, 'move'));\n            window.addEventListener('mouseup', e => this.handleInput(e.clientX, e.clientY, 'end'));\n            \n            this.wrapper.addEventListener('touchstart', e => {\n                e.preventDefault();\n                this.handleInput(e.touches[0].clientX, e.touches[0].clientY, 'start');\n            }, {passive: false});\n            window.addEventListener('touchmove', e => {\n                if (this.isDraggingNode || this.isPanning) e.preventDefault();\n                this.handleInput(e.touches[0].clientX, e.touches[0].clientY, 'move');\n            }, {passive: false});\n            window.addEventListener('touchend', e => this.handleInput(0, 0, 'end'));\n\n            this.wrapper.addEventListener('wheel', e => {\n                e.preventDefault();\n                const delta = e.deltaY > 0 ? 0.9 : 1.1;\n                this.scale = Math.max(0.2, Math.min(3, this.scale * delta));\n                this.draw();\n            });\n            window.addEventListener('resize', () => this.draw());\n        }\n    }\n\n    window.game = new KnotGame();\n});\n</script>\n<p><a href=\"/DMs\" class=\"btn\">è¿›å…¥ç«™å†…ä¿¡</a></p>\n",
  "answer": "POPCORN",
  "desc": "<font color=\"#808080\">ä¸ºä»€ä¹ˆè®¸å¤šäººæ¯å¤©æ²¿ç€è¿™äº›ç»³å­èµ°ï¼Ÿ</font>",
  "tips": [
    {
      "title": "ç¬¬ä¸ƒé¢˜éš¾åº¦å¤ªå¤§äº†ï¼æˆ–è®¸æˆ‘å¿½ç•¥äº†ä»€ä¹ˆï¼Ÿ (2æç¤ºç‚¹)",
      "content": "ä½ å¯ä»¥æ³¨æ„ä¸€ä¸‹è¿™äº›èŠ‚ç‚¹çš„é¢œè‰²ï¼ŒæŠŠå®ƒä»¬è”ç³»åˆ°ftä¸Šã€‚"
    },
    {
      "title": "è¿™é“é¢˜çš„ä¸»é¢˜æ˜¯ä»€ä¹ˆï¼Ÿ (2æç¤ºç‚¹)",
      "content": "åœ°é“ã€‚"
    },
    {
      "title": "è¿™äº›é¢˜ç›®åˆ†åˆ«å¯¹åº”ä»€ä¹ˆï¼Ÿ (6æç¤ºç‚¹)",
      "content": "è¯·å°†æœ¬é¢˜ä¸»é¢˜å¯¹åº”çš„è¯è¯­ï¼ˆä¸­å›½å¤§é™†ç”¨æ³•ï¼‰é‡å¤ä¸¤éè¿›è¡Œæäº¤ï¼Œé‡Œç¨‹ç¢‘ä¼šè¿›è¡Œè¿›ä¸€æ­¥çš„åé¦ˆã€‚"
    },
    {
      "title": "è¯¥å¦‚ä½•æå–ï¼Ÿ (3æç¤ºç‚¹)",
      "content": "æ‰¾åˆ°æ ‡æœ‰æ•°å­—çš„èŠ‚ç‚¹çš„è‹±æ–‡åï¼Œç”¨è¿™äº›æ•°å­—æå–ä½æ•°ã€‚"
    }
  ],
  "additionalAnswers": [
    {
      "answer": "åœ°é“åœ°é“",
      "message": "æ¯é“é¢˜å¯¹åº”çš„åŸå¸‚åˆ†åˆ«æ˜¯ï¼šå…°å·ã€å“ˆå°”æ»¨ã€å—æ˜Œã€æ— é”¡ã€å—å®ã€æ˜†æ˜ã€å®æ³¢ã€‚"
    }
  ],
  "links": [
    {
      "title": "ç´¢å¼•é¡µ",
      "type": "index",
      "path": "seco2/index"
    },
    {
      "title": "åº„å›­",
      "path": "/area/seco2/1",
      "pgid": 1
    },
    {
      "title": "æ²™æµ·",
      "path": "/area/seco2/2",
      "pgid": 2
    },
    {
      "title": "é«˜å¡”",
      "path": "/area/seco2/3",
      "pgid": 3
    },
    {
      "title": "èŠ±åŸ",
      "path": "/area/seco2/4",
      "pgid": 4
    },
    {
      "title": "æš—æ ¼",
      "path": "/area/seco2/5",
      "pgid": 5
    },
    {
      "title": "è¿‡æ¸¡",
      "path": "/area/seco2/6",
      "pgid": 6
    },
    {
      "title": "ä¸­å¿ƒ",
      "path": "/area/seco2/7",
      "pgid": 7
    },
    {
      "title": "FM",
      "path": "/area/seco2/8",
      "pgid": 8
    }
  ],
  "arealink": {
    "title": "æ²™æµ·",
    "path": "/area/seco2/2",
    "pgid": 2
  }
}