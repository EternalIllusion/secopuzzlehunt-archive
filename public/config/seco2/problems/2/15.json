{
  "type": "problem",
  "title": "移言为定",
  "extendData": "",
  "contentType": 1,
  "content": "<div class=\"yiyan-body-wrap\">\n\n<div class=\"yiyan-buttons\" style=\"max-width: 900px; margin: 0 0 0 0; padding: 0 20px 8px 0; display: flex; justify-content: space-between; align-items: center;\">\n<button id=\"skip-btn\" class=\"skip-btn skip-btn-inline hidden\">跳过 ▼</button>\n<button id=\"reset-btn\" class=\"skip-btn skip-btn-inline\" style=\"background: #d9534f; margin-left: auto;\">重置进度</button>\n</div>\n\n<style>\n.yiyan-body-wrap { box-sizing: border-box; margin-left: 24px; margin-right: auto; max-width: 900px; }\n.yiyan-quote { font-family: \"Microsoft YaHei\", sans-serif; font-size: 16px; }\n#wordgame-container {\n    font-family: \"Microsoft YaHei\", sans-serif;\n    line-height: 1.6;\n    font-size: 16px;\n    max-width: 900px;\n    margin: 0 0 20px 0;\n    padding: 20px 20px 20px 0;\n    position: relative;\n}\n\n#content {\n    max-height: 200px;\n    overflow-y: auto;\n    padding-right: 10px;\n    margin-bottom: 80px;\n}\n\n#content::-webkit-scrollbar {\n    width: 8px;\n}\n\n#content::-webkit-scrollbar-track {\n    background: #f1f1f1;\n    border-radius: 4px;\n}\n\n#content::-webkit-scrollbar-thumb {\n    background: #888;\n    border-radius: 4px;\n}\n\n#content::-webkit-scrollbar-thumb:hover {\n    background: #555;\n}\n\n.wordgame-text {\n    margin-bottom: 8px;\n}\n\n.wordgame-text.double-spacing {\n    margin-bottom: 16px;\n}\n\n.wordgame-char {\n    display: inline;\n    opacity: 0;\n}\n\n.wordgame-char.visible {\n    animation: fadeIn 0.1s forwards;\n}\n\n@keyframes fadeIn {\n    to { opacity: 1; }\n}\n\n.wordgame-bold {\n    font-weight: bold;\n    text-indent: 2em;\n    display: block;\n}\n\n.wordgame-hint {\n    color: #808080;\n    font-style: italic;\n    margin: 15px 0;\n}\n\n.wordgame-bracket {\n    color: #d9534f;\n    font-weight: bold;\n    margin: 10px 0;\n}\n\n.wordgame-input-container {\n    margin: 10px 0;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 5px;\n}\n\n.wordgame-input {\n    padding: 8px;\n    font-size: 16px;\n    border: 2px solid #ccc;\n    border-radius: 4px;\n    width: 200px;\n    margin-right: 10px;\n}\n\n.wordgame-input:focus {\n    border-color: #5cb85c;\n    outline: none;\n}\n\n.skip-btn {\n    position: fixed;\n    top: 30px;\n    left: 30px;\n    padding: 10px 20px;\n    background: #5cb85c;\n    color: white;\n    border: none;\n    border-radius: 25px;\n    cursor: pointer;\n    font-size: 14px;\n    box-shadow: 0 4px 8px rgba(0,0,0,0.2);\n    z-index: 1000;\n    transition: all 0.3s ease;\n}\n\n.skip-btn:hover {\n    background: #4cae4c;\n    transform: scale(1.05);\n    box-shadow: 0 6px 12px rgba(0,0,0,0.3);\n}\n\n/* 引文下方的按钮：取消固定定位，避免压在引文上；重置在右 */\n.skip-btn-inline {\n    position: static !important;\n    top: auto;\n    left: auto;\n}\n\n.submit-btn {\n    padding: 8px 20px;\n    background: #0275d8;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 16px;\n}\n\n.submit-btn:hover {\n    background: #025aa5;\n}\n\n.submit-btn:disabled {\n    background: #ccc;\n    cursor: not-allowed;\n}\n\n.highlight {\n    animation: glow 1s ease-in-out;\n}\n\n.max-glow {\n    animation: maxGlow 2s ease-in-out;\n}\n\n@keyframes glow {\n    0%, 100% { text-shadow: none; }\n    50% { text-shadow: 0 0 10px #ffd700; }\n}\n\n@keyframes maxGlow {\n    0%, 100% { text-shadow: 0 0 20px #ffd700, 0 0 30px #ffd700; }\n    50% { text-shadow: 0 0 30px #ffd700, 0 0 40px #ffd700, 0 0 50px #ffd700; }\n}\n\n.fade-out {\n    animation: fadeOut 0.1s forwards;\n}\n\n@keyframes fadeOut {\n    to { opacity: 0; display: none; }\n}\n\n.hidden {\n    display: none;\n}\n\n.loading {\n    text-align: center;\n    padding: 40px;\n    color: #666;\n}\n</style>\n\n<div id=\"wordgame-container\">\n    <div class=\"loading\">加载中...</div>\n    <div id=\"content\"></div>\n    <div id=\"input-area\"></div>\n    <div id=\"final-hint\" style=\"margin-top: 30px; padding: 20px; background: #e7f3ff; border-radius: 8px; border: 2px solid #0275d8;\" class=\"hidden\"></div>\n</div>\n</div>\n\n<script>\nconst PUZZLE_SLUG = '{{ puzzle.slug }}';\nlet storyContent = [];\nlet currentIndex = 0;\nlet currentText = '';\nlet currentCharIndex = 0;\nlet isTyping = false;\nlet skipToNextParagraph = false;\nlet typingInterval;\nlet currentParagraphId = 0;\nlet completedStage = 0; // 已完成的阶段\n\n// 用于跟踪当前正在打字的状态\nlet currentTypingElement = null;\nlet currentTypingText = '';\nlet currentTypingIndex = 0;\nlet currentTypingCallback = null;\nlet autoSkipTargetIndex = -1;\nlet stageStartParagraphId = 0; // 记录当前阶段开始的段落ID，用于限制修改范围\n\nlet currentPart = 0; // 当前所处的部分（0-3）\n\n// Transformation Animation State\nlet isProcessingTransformation = false;\nlet currentTransformationItem = null;\nlet skipTransformationFlag = false;\n\n// 从后端加载故事内容和进度\nasync function loadStoryContent() {\n    try {\n        // 并行加载故事内容和进度\n        const [storyResponse, progressResponse] = await Promise.all([\n            fetch(`/puzzle/${PUZZLE_SLUG}/handler/?action=get_story`),\n            fetch(`/puzzle/${PUZZLE_SLUG}/handler/?action=get_progress`)\n        ]);\n        \n        const storyData = await storyResponse.json();\n        const progressData = await progressResponse.json();\n        \n        if (storyData.success) {\n            storyContent = storyData.story;\n            \n            // 获取已完成的阶段\n            if (progressData.success) {\n                completedStage = progressData.completed_stage || 0;\n                \n                // 如果有快照，直接渲染快照内容\n                if (progressData.snapshot && progressData.snapshot.length > 0) {\n                    progressData.snapshot.forEach(item => {\n                        const p = document.createElement('p');\n                        p.className = `wordgame-text ${item.class}`;\n                        p.innerHTML = item.html;\n                        document.getElementById('content').appendChild(p);\n                        currentParagraphId++;\n                    });\n                    \n                    // 快照已经包含了之前所有阶段的内容\n                    // 现在需要跳到下一个阶段继续\n                    document.querySelector('.loading').style.display = 'none';\n                    \n                    // 设置阶段开始边界：当前所有快照生成的段落都不受新阶段影响\n                    stageStartParagraphId = currentParagraphId;\n\n                    if (completedStage >= 3) {\n                        // 所有阶段都完成了，显示最终提示\n                        skipToFinalHint();\n                    } else {\n                        // 跳到下一个阶段的输入\n                        skipToNextStage(completedStage + 1);\n                    }\n                    return;\n                }\n            }\n            \n            document.querySelector('.loading').style.display = 'none';\n            \n            // 没有快照，从头开始\n            processNext();\n        } else {\n            document.querySelector('.loading').textContent = '加载失败：' + storyData.error;\n        }\n    } catch (error) {\n        console.error('Error loading story:', error);\n        document.querySelector('.loading').textContent = '加载失败，请刷新页面重试';\n    }\n}\n\n// 跳到下一个阶段（从storyContent中找到对应位置）\nfunction skipToNextStage(targetStage) {\n    // 找到上一个阶段（已完成）的input位置，从它之后开始渲染\n    const prevStage = targetStage - 1;\n    \n    for (let i = 0; i < storyContent.length; i++) {\n        const item = storyContent[i];\n        \n        if (item.type === 'input') {\n            const stageNum = parseInt(item.stage.replace('stage', ''));\n            \n            if (stageNum === prevStage) {\n                // 找到上一个阶段的input，从下一个位置开始渲染\n                currentIndex = i + 1;\n                processNext();\n                return;\n            }\n        }\n    }\n}\n\n// 跳到最终提示\nfunction skipToFinalHint() {\n    for (let i = 0; i < storyContent.length; i++) {\n        const item = storyContent[i];\n        \n        if (item.type === 'final_hint') {\n            // 找到最终提示，从这里开始\n            currentIndex = i;\n            processNext();\n            return;\n        }\n    }\n}\n\nfunction addContent(text, className = '') {\n    const p = document.createElement('p');\n    p.className = `wordgame-text ${className}`;\n    p.id = `paragraph-${currentParagraphId++}`;\n    document.getElementById('content').appendChild(p);\n    \n    // 自动滚动到底部\n    const contentDiv = document.getElementById('content');\n    contentDiv.scrollTop = contentDiv.scrollHeight;\n    \n    return p;\n}\n\nfunction typeText(element, text, callback, charDelay = 50, partNum = null) {\n    isTyping = true;\n    let index = 0;\n    const skipBtn = document.getElementById('skip-btn');\n    skipBtn.classList.remove('hidden');\n    skipToNextParagraph = false;\n    \n    // 保存当前打字状态，供 handleSkip 使用\n    currentTypingElement = element;\n    currentTypingText = text;\n    currentTypingIndex = index;\n    currentTypingCallback = callback;\n    \n    // 如果指定了部分编号，更新全局的currentPart\n    if (partNum !== null) {\n        currentPart = partNum;\n    }\n    \n    typingInterval = setInterval(() => {\n        // 自动滚动到底部，确保最新字符可见\n        const contentDiv = document.getElementById('content');\n        contentDiv.scrollTop = contentDiv.scrollHeight;\n\n        if (skipToNextParagraph) {\n            // 立即完成当前文本的剩余部分\n            while (index < text.length) {\n                const char = text[index];\n                if (char === '\\n') {\n                    // 检查是否是双换行\n                    if (index < text.length - 1 && text[index + 1] === '\\n') {\n                        // 双换行 -> 两个 <br>\n                        element.appendChild(document.createElement('br'));\n                        element.appendChild(document.createElement('br'));\n                        index++;\n                    } else {\n                        // 单换行\n                        element.appendChild(document.createElement('br'));\n                    }\n                } else {\n                    const span = document.createElement('span');\n                    span.className = 'wordgame-char visible';\n                    span.textContent = char;\n                    element.appendChild(span);\n                }\n                index++;\n            }\n            // 完成后结束打字\n            clearInterval(typingInterval);\n            isTyping = false;\n            skipBtn.classList.add('hidden');\n            skipToNextParagraph = false;\n            if (callback) callback();\n            return;\n        }\n        \n        if (index < text.length) {\n            const char = text[index];\n                if (char === '\\n') {\n                    // 如果位于文本开头（且是新段落），只需要一个 <br> 来产生空行\n                    // 否则需要两个 <br> 来产生空行\n                    if (index === 0) {\n                         element.appendChild(document.createElement('br'));\n                    } else {\n                         element.appendChild(document.createElement('br'));\n                         element.appendChild(document.createElement('br'));\n                    }\n                    \n                    // 如果后面紧跟另一个换行符，跳过它（将 \\n 和 \\n\\n 都视为一个空行）\n                    if (index < text.length - 1 && text[index + 1] === '\\n') {\n                        index++;\n                    }\n                } else {\n                const span = document.createElement('span');\n                span.className = 'wordgame-char';\n                span.textContent = char;\n                element.appendChild(span);\n                setTimeout(() => span.classList.add('visible'), 10);\n            }\n            index++;\n            currentTypingIndex = index; // 更新全局索引\n        } else {\n            clearInterval(typingInterval);\n            isTyping = false;\n            skipBtn.classList.add('hidden');\n            if (callback) callback();\n        }\n    }, charDelay);\n}\n\nfunction handleSkip() {\n    if (isProcessingTransformation) {\n        skipTransformationFlag = true;\n        fastForwardTransformations(currentTransformationItem);\n        return;\n    }\n\n    if (isTyping) {\n        // 完成当前正在打字的文本\n        \n        // 同时，如果后续有相同类型的文本，也一并跳过\n        // currentIndex 此时指向的是 *下一条* 将要处理的文本（因为 processNext 在调用 typeText 前已经 increment 了 currentIndex）\n        // 所以我们正在打字的是 storyContent[currentIndex - 1]\n        \n        if (currentIndex > 0) {\n            const currentItem = storyContent[currentIndex - 1];\n            const currentType = currentItem.type;\n            \n            // 查找后续所有相同类型的项，直到遇到不同类型为止\n            let target = currentIndex;\n            while (target < storyContent.length && storyContent[target].type === currentType) {\n                target++;\n            }\n            \n            // 如果找到了可以跳过的后续项\n            if (target > currentIndex) {\n                autoSkipTargetIndex = target;\n            }\n        }\n        \n        skipToNextParagraph = true;\n    } else {\n        // 不在打字，跳到下一个部分\n        skipToNextPart();\n    }\n}\n\n// 跳到下一个部分\n// 每个阶段分为4个部分：\n// Part 0: 开头的normal文本（语言与描写）- 直到遇到bold\n// Part 1: bold文本（需要改动的句子）\n// Part 2: bold后的normal文本（对应剧情）- 直到遇到hint\n// Part 3: hint+bracket（关于改动的提示）\nfunction skipToNextPart() {\n    // 当前part: 0-3\n    // 找到下一个关键点\n    \n    let foundNextPart = false;\n    \n    for (let i = currentIndex; i < storyContent.length; i++) {\n        const item = storyContent[i];\n        \n        // 根据当前part和item类型判断是否到达下一部分\n        if (currentPart === 0 && item.type === 'bold') {\n            // 从Part 0跳到Part 1（bold）\n            skipToIndexAndContinue(i);\n            foundNextPart = true;\n            break;\n        } else if (currentPart === 1 && item.type === 'normal') {\n            // 从Part 1跳到Part 2（bold后的normal）\n            skipToIndexAndContinue(i);\n            foundNextPart = true;\n            break;\n        } else if (currentPart === 2 && item.type === 'hint') {\n            // 从Part 2跳到Part 3（hint）\n            skipToIndexAndContinue(i);\n            foundNextPart = true;\n            break;\n        } else if (currentPart === 3 && item.type === 'input') {\n            // 从Part 3跳到输入框\n            skipToIndexAndContinue(i);\n            foundNextPart = true;\n            break;\n        }\n    }\n    \n    if (!foundNextPart) {\n        // 没有找到下一部分，可能已到达当前阶段末尾\n        // 继续正常流程\n        processNext();\n    }\n}\n\n// 跳到指定索引并继续，中间的文本立即显示\nfunction skipToIndexAndContinue(targetIndex) {\n    // 立即显示从currentIndex到targetIndex之间的所有文本\n    while (currentIndex < targetIndex) {\n        const item = storyContent[currentIndex];\n        currentIndex++;\n        \n        if (item.type === 'normal') {\n            const p = addContent('');\n            renderTextWithLineBreaks(p, item.text);\n        } else if (item.type === 'bold') {\n            const p = addContent('', 'wordgame-bold');\n            renderTextWithLineBreaks(p, item.text);\n        } else if (item.type === 'hint') {\n            const p = addContent('', 'wordgame-hint');\n            renderTextWithLineBreaks(p, item.text);\n        } else if (item.type === 'bracket') {\n            const p = addContent('', 'wordgame-bracket');\n            p.textContent = item.text;\n        }\n    }\n    \n    // 然后继续正常处理\n    processNext();\n}\n\n// 跳到下一个输入框（跳过所有文本动画）\nfunction skipToNextInput() {\n    // 从当前位置开始查找下一个input，并立即渲染所有中间的文本\n    for (let i = currentIndex; i < storyContent.length; i++) {\n        const item = storyContent[i];\n        \n        if (item.type === 'input') {\n            // 找到下一个input，显示它\n            currentIndex = i + 1; // 设置为input之后，以便后续继续\n            showInput(item);\n            return;\n        } else if (item.type === 'normal') {\n            // 立即显示普通文本，处理换行符\n            const p = addContent('');\n            renderTextWithLineBreaks(p, item.text);\n        } else if (item.type === 'bold') {\n            // 立即显示粗体文本，处理换行符\n            const p = addContent('', 'wordgame-bold');\n            renderTextWithLineBreaks(p, item.text);\n        } else if (item.type === 'hint') {\n            // 立即显示提示文本，处理换行符\n            const p = addContent('', 'wordgame-hint');\n            renderTextWithLineBreaks(p, item.text);\n        } else if (item.type === 'bracket') {\n            // 立即显示括号文本\n            const p = addContent('', 'wordgame-bracket');\n            p.textContent = item.text;\n        }\n    }\n    \n    // 没有找到input，说明到达最终提示\n    for (let i = currentIndex; i < storyContent.length; i++) {\n        const item = storyContent[i];\n        \n        if (item.type === 'final_hint') {\n            currentIndex = i;\n            processNext();\n            return;\n        }\n    }\n}\n\n// 辅助函数：渲染带换行符的文本\nfunction renderTextWithLineBreaks(element, text) {\n    // 将双换行分割为段落\n    const parts = text.split('\\n\\n');\n    parts.forEach((part, index) => {\n        if (index > 0) {\n            element.appendChild(document.createElement('br'));\n            element.appendChild(document.createElement('br'));\n        }\n        // 将单换行替换为<br>\n        const lines = part.split('\\n');\n        lines.forEach((line, lineIndex) => {\n            if (lineIndex > 0) {\n                // 如果这是第二行且第一行是空的，说明原始文本以 \\n 开头\n                // 这种情况下，我们只需要一个 <br>\n                if (lineIndex === 1 && lines[0] === '') {\n                     element.appendChild(document.createElement('br'));\n                } else {\n                     element.appendChild(document.createElement('br'));\n                     element.appendChild(document.createElement('br'));\n                }\n            }\n            for (const char of line) {\n                const span = document.createElement('span');\n                span.className = 'wordgame-char visible'; // Visible immediately\n                span.textContent = char;\n                element.appendChild(span);\n            }\n        });\n    });\n}\n\nfunction showInput(item) {\n    const stageNum = parseInt(item.stage.replace('stage', ''));\n    \n    const container = document.createElement('div');\n    container.className = 'wordgame-input-container';\n    container.id = `input-${item.stage}`;\n    \n    const input = document.createElement('input');\n    input.type = 'text';\n    input.className = 'wordgame-input';\n    input.placeholder = '请输入...';\n    \n    const btn = document.createElement('button');\n    btn.className = 'submit-btn';\n    btn.textContent = '提交';\n    \n    btn.onclick = async () => {\n        const value = input.value.trim();\n        if (!value) return;\n        \n        btn.disabled = true;\n        btn.textContent = '验证中...';\n        \n        try {\n            const response = await fetch(`/puzzle/${PUZZLE_SLUG}/handler/`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value\n                },\n                body: JSON.stringify({\n                    action: 'validate',\n                    stage: item.stage,\n                    input: value\n                })\n            });\n            \n            const data = await response.json();\n            \n            if (data.correct) {\n                // 更新本地进度\n                completedStage = Math.max(completedStage, stageNum);\n                \n                container.remove();\n                applyTransformations(item);\n            } else {\n                btn.textContent = '答案错误，请重试';\n                setTimeout(() => {\n                    btn.textContent = '提交';\n                    btn.disabled = false;\n                }, 1500);\n            }\n        } catch (error) {\n            console.error('Error:', error);\n            btn.textContent = '提交';\n            btn.disabled = false;\n        }\n    };\n    \n    input.addEventListener('keypress', (e) => {\n        if (e.key === 'Enter') btn.click();\n    });\n    \n    container.appendChild(input);\n    container.appendChild(btn);\n    // 清空input-area并添加新的输入框\n    const inputArea = document.getElementById('input-area');\n    inputArea.innerHTML = '';\n    inputArea.appendChild(container);\n    \n    // Scroll to input\n    setTimeout(() => {\n        const contentDiv = document.getElementById('content');\n        contentDiv.scrollTop = contentDiv.scrollHeight;\n    }, 100);\n}\n\nfunction fastForwardTransformations(item) {\n    // Reset states\n    isProcessingTransformation = false;\n    isTyping = false;\n    clearInterval(typingInterval);\n    document.getElementById('skip-btn').classList.add('hidden');\n    \n    // 1. Force remove hints and brackets\n    const content = document.getElementById('content');\n    const hintsAndBrackets = content.querySelectorAll('.wordgame-hint, .wordgame-bracket');\n    hintsAndBrackets.forEach(el => el.remove());\n    \n    let lastRemovedElement = null;\n\n    // 2. Force remove texts\n    // Re-calculate removal targets to ensure we catch them\n    if (item.removes) {\n        item.removes.forEach(removeText => {\n            const allParagraphs = Array.from(content.querySelectorAll('.wordgame-text'));\n            const paragraphs = allParagraphs.filter(p => {\n                const pid = parseInt(p.id.split('-')[1]);\n                return pid >= stageStartParagraphId;\n            });\n            \n            for (const p of paragraphs) {\n                const text = p.textContent;\n                const startIdx = text.indexOf(removeText);\n                if (startIdx !== -1) {\n                    lastRemovedElement = p;\n                    const chars = Array.from(p.querySelectorAll('.wordgame-char'));\n                    // Hide chars\n                    for (let j = 0; j < removeText.length; j++) {\n                        if (chars[startIdx + j]) {\n                            chars[startIdx + j].style.display = 'none';\n                            chars[startIdx + j].classList.add('fade-out'); // Ensure marked\n                        }\n                    }\n                }\n            }\n        });\n    }\n    \n    // 3. Force add text\n    if (item.adds) {\n        let targetElement = lastRemovedElement;\n\n        if (!targetElement) {\n             // Fallback: Search backwards for a paragraph that has hidden chars\n            const allPs = Array.from(content.querySelectorAll('.wordgame-text'));\n            for (let i = allPs.length - 1; i >= 0; i--) {\n                if (allPs[i].querySelector('.wordgame-char[style*=\"none\"]')) {\n                     targetElement = allPs[i];\n                     break;\n                }\n            }\n        }\n        \n        if (!targetElement) {\n            targetElement = addContent('');\n        }\n        \n        renderTextWithLineBreaks(targetElement, item.adds);\n    }\n    \n    stageStartParagraphId = currentParagraphId;\n    \n    // Continue\n    setTimeout(() => processNext(), 100);\n}\n\nfunction applyTransformations(item) {\n    isProcessingTransformation = true;\n    currentTransformationItem = item;\n    skipTransformationFlag = false;\n    document.getElementById('skip-btn').classList.remove('hidden');\n\n    const content = document.getElementById('content');\n    \n    // 隐藏提示和括号\n    const hintsAndBrackets = content.querySelectorAll('.wordgame-hint, .wordgame-bracket');\n    hintsAndBrackets.forEach(el => {\n        el.classList.add('fade-out');\n        // 动画结束后移除元素以释放空间\n        setTimeout(() => {\n            el.remove();\n        }, 500);\n    });\n    \n    // 应用替换\n    item.replacements.forEach(rep => {\n        // 只筛选当前阶段生成的段落\n        const allParagraphs = Array.from(content.querySelectorAll('.wordgame-text'));\n        const paragraphs = allParagraphs.filter(p => {\n            const pid = parseInt(p.id.split('-')[1]);\n            return pid >= stageStartParagraphId;\n        });\n\n        paragraphs.forEach(p => {\n            const text = p.textContent;\n            if (text.includes(rep.from)) {\n                const glowClass = rep.glow === 'max' ? 'max-glow' : 'highlight';\n                \n                // 重建HTML，保留 <br> 和其他标签\n                let reconstruct = '';\n                p.childNodes.forEach(child => {\n                    if (child.nodeName === 'BR') {\n                        reconstruct += '<br>';\n                    } else if (child.nodeType === 3) { // Text node\n                        reconstruct += child.textContent;\n                    } else if (child.classList && child.classList.contains('wordgame-char')) {\n                        reconstruct += child.textContent;\n                    } else {\n                        // 保留其他元素（如之前的 strong）\n                        reconstruct += child.outerHTML;\n                    }\n                });\n                \n                if (reconstruct.includes(rep.from)) {\n                    const escaped = rep.from.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n                    const newHTML = reconstruct.replace(\n                        new RegExp(escaped, 'g'),\n                        `<strong class=\"${glowClass}\">${rep.to}</strong>`\n                    );\n                    p.innerHTML = newHTML;\n                }\n            }\n        });\n    });\n    \n    // 将所有需要移除的任务放入队列，按顺序排列\n    const removeTasks = [];\n    \n    // 遍历 remves 列表，逐个查找匹配项\n    // 关键修正：对于每个 removeText，我们只找 *第一次* 匹配且 *未被之前任务占用* 的位置\n    // 这样可以确保按顺序一个接一个地移除\n    \n    // 用于记录已经被占用的段落索引，避免重复处理同一段落（如果这是期望的行为）\n    // 或者更细粒度地，记录字符位置。这里简单起见，假设每次移除都是独立的文本块\n    \n    item.removes.forEach(removeText => {\n        // 只筛选当前阶段生成的段落\n        const allParagraphs = Array.from(document.getElementById('content').querySelectorAll('.wordgame-text'));\n        const paragraphs = allParagraphs.filter(p => {\n            const pid = parseInt(p.id.split('-')[1]);\n            return pid >= stageStartParagraphId;\n        });\n\n        let taskFound = false;\n        \n        for (let i = 0; i < paragraphs.length; i++) {\n            if (taskFound) break;\n            \n            const p = paragraphs[i];\n            const text = p.textContent;\n            \n            // 查找文本位置\n            const startIdx = text.indexOf(removeText);\n            \n            if (startIdx !== -1) {\n                // 检查这段文本是否已经被标记为要移除了（通过检查字符是否已经有 fade-out 类）\n                const chars = Array.from(p.querySelectorAll('.wordgame-char'));\n                \n                // 简单的检查：如果起始字符还没有 fade-out 类，那么这是一个新的匹配\n                // 注意：这里假设 removeText 对应的字符在 DOM 中是连续的 wordgame-char span\n                if (chars[startIdx] && !chars[startIdx].classList.contains('fade-out') && !chars[startIdx].dataset.removing) {\n                    \n                    // 标记这些字符即将被移除，防止被后续的 removeText 再次匹配\n                    for (let j = 0; j < removeText.length; j++) {\n                        if (chars[startIdx + j]) {\n                            chars[startIdx + j].dataset.removing = \"true\";\n                        }\n                    }\n                    \n                    removeTasks.push({\n                        chars: chars,\n                        startIdx: startIdx,\n                        length: removeText.length\n                    });\n                    taskFound = true;\n                }\n            }\n        }\n    });\n    \n    // 使用Promise链按顺序执行移除动画\n    let promiseChain = Promise.resolve();\n    \n    // 在开始移除文本前，等待hint消失动画的一半时间\n    promiseChain = promiseChain.then(() => {\n        if (skipTransformationFlag) return Promise.reject('skipped');\n        return new Promise(resolve => setTimeout(resolve, 250));\n    });\n    \n    removeTasks.forEach(task => {\n        // 为每一段要删除的文本创建一个任务\n        promiseChain = promiseChain.then(() => {\n            if (skipTransformationFlag) return Promise.reject('skipped');\n            return new Promise(resolve => {\n                // 从右往左移除这段文本\n                let completedCount = 0;\n                const totalChars = task.length;\n                \n                // 如果没有字符需要移除（例如文本未找到），直接 resolve\n                if (totalChars === 0) {\n                    resolve();\n                    return;\n                }\n\n                // 逐个字符设置动画\n                for (let i = task.length - 1; i >= 0; i--) {\n                    // Check skip inside loop for reducing timeout spam if skipped immediately\n                    if (skipTransformationFlag) {\n                        // resolve() or reject? If we reject here, we need to handle it.\n                        // But we are inside a sync loop creating async timeouts.\n                        // We can't easily stop the loop's effect once scheduled unless we track timeouts.\n                        // But fastForwardTransformations will hide everything anyway.\n                    }\n                    \n                    setTimeout(() => {\n                        if (skipTransformationFlag) return; // Don't animate if skipped\n                        \n                        const charIdx = task.startIdx + i;\n                        const targetChar = task.chars[charIdx];\n                        if (targetChar) {\n                            targetChar.classList.add('fade-out');\n                            setTimeout(() => {\n                                if (!skipTransformationFlag) targetChar.style.display = 'none';\n                            }, 150); \n                        }\n                        \n                        completedCount++;\n                        \n                        if (completedCount === totalChars) {\n                            if (!skipTransformationFlag) setTimeout(resolve, 200);\n                        }\n                    }, (task.length - 1 - i) * 50); \n                }\n                \n                // Safety resolve if skipped during this task setup? \n                // No, the timeouts handle the flow.\n            });\n        });\n    });\n    \n    // 所有文本移除完成后，等待1秒，然后添加新文本，再继续下一阶段\n    promiseChain.then(() => {\n        if (skipTransformationFlag) return Promise.reject('skipped');\n        // 等待 500ms 的暂停时间，让用户看到“空白”或“消失后的状态”\n        return new Promise(resolve => setTimeout(resolve, 500));\n    }).then(() => {\n        if (skipTransformationFlag) return Promise.reject('skipped');\n        \n        // 确定添加文本的位置：尝试找到最后一段被移除文本所在的段落\n        let targetElement = null;\n        if (removeTasks.length > 0) {\n            const lastTask = removeTasks[removeTasks.length - 1];\n            if (lastTask.chars && lastTask.chars.length > 0) {\n                targetElement = lastTask.chars[0].parentElement;\n            }\n        }\n        \n        // 如果没找到（或者没有移除任务），则新建一个段落\n        if (!targetElement) {\n            targetElement = addContent('');\n        }\n        \n        // 逐字显示新文本\n        if (item.adds) {\n             typeText(targetElement, item.adds, () => {\n                 isProcessingTransformation = false; // Done\n                 // 打字完成后，更新阶段边界（新阶段将从此处之后开始）\n                 stageStartParagraphId = currentParagraphId;\n                 \n                 // 稍作停顿再继续下一阶段\n                 setTimeout(() => processNext(), 500);\n             }, 50);\n        } else {\n             isProcessingTransformation = false; // Done\n             // 如果没有新文本要添加，直接继续\n             stageStartParagraphId = currentParagraphId;\n             setTimeout(() => processNext(), 500);\n        }\n    }).catch(reason => {\n        if (reason === 'skipped') {\n            console.log('Transformation skipped');\n        } else {\n            console.error(reason);\n        }\n    });\n}\n\nfunction processNext() {\n    if (currentIndex >= storyContent.length) return;\n    \n    // 检查是否需要自动跳过（处理同类型文本的批量显示）\n    if (autoSkipTargetIndex > currentIndex) {\n        skipToIndexAndContinue(autoSkipTargetIndex);\n        autoSkipTargetIndex = -1; // 重置\n        return; // skipToIndexAndContinue 会再次调用 processNext\n    }\n    \n    const item = storyContent[currentIndex];\n    currentIndex++;\n    \n    // 判断当前处于哪个部分，传递给typeText\n    let partNum = null;\n    if (item.type === 'normal') {\n        // normal可能是Part 1或Part 3，通过前后文判断\n        // 简化：检查之前是否有bold，如果有则是Part 3，否则是Part 1\n        let hasBoldBefore = false;\n        for (let i = 0; i < currentIndex - 1; i++) {\n            if (storyContent[i].type === 'bold') {\n                hasBoldBefore = true;\n                break;\n            }\n        }\n        partNum = hasBoldBefore ? 2 : 0; // Part 3或Part 1\n    } else if (item.type === 'bold') {\n        partNum = 1; // Part 2\n    } else if (item.type === 'hint' || item.type === 'bracket') {\n        partNum = 3; // Part 4\n    }\n    \n    if (item.type === 'normal') {\n        const p = addContent('');\n        typeText(p, item.text, processNext, 50, partNum);\n    } else if (item.type === 'bold') {\n        const p = addContent('', 'wordgame-bold');\n        typeText(p, item.text, processNext, 50, partNum);\n    } else if (item.type === 'hint') {\n        const p = addContent('', 'wordgame-hint');\n        typeText(p, item.text, processNext, 50, partNum);\n    } else if (item.type === 'bracket') {\n        const p = addContent('', 'wordgame-bracket');\n        typeText(p, item.text, processNext, 50, partNum);\n    } else if (item.type === 'input') {\n        showInput(item);\n    } else if (item.type === 'final_hint') {\n        // 显示最终提示文本（醒目颜色）\n        const hintDiv = document.getElementById('final-hint');\n        hintDiv.innerHTML = item.text.split('\\n').map(line => \n            `<p style=\"color: #d9534f; font-weight: bold; margin: 5px 0;\">${line}</p>`\n        ).join('');\n        hintDiv.classList.remove('hidden');\n        processNext();\n    } else if (item.type === 'final') {\n        // 不显示输入框，直接完成\n    }\n}\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    document.getElementById('skip-btn').addEventListener('click', handleSkip);\n    \n    document.getElementById('reset-btn').addEventListener('click', async () => {\n        if (!confirm('确定要重置进度吗？所有已完成的阶段将丢失。')) return;\n        \n        try {\n            const response = await fetch(`/puzzle/${PUZZLE_SLUG}/handler/`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value\n                },\n                body: JSON.stringify({ action: 'reset' })\n            });\n            \n            const data = await response.json();\n            if (data.success) {\n                location.reload();\n            } else {\n                alert('重置失败：' + (data.error || '未知错误'));\n            }\n        } catch (error) {\n            console.error('Error resetting:', error);\n            alert('重置失败，请检查网络连接');\n        }\n    });\n    \n    loadStoryContent();\n});\n</script>\n\n  ",
  "answer": "MARINE",
  "desc": "<font color=\"#808080\"><i>我们说好，每160天在这里交换一个勺绽。</i></font>",
  "tips": [
    {
      "title": "我毫无头绪！ (2提示点)",
      "content": "这道题是对《文字游戏》的模仿，你需要按照指引修改文案推进剧情。"
    },
    {
      "title": "我想不出第一次修改！ (1提示点)",
      "content": "按照指引，你需要把“隐语”的一个部件移到“日光”上。"
    },
    {
      "title": "我想不出第二次修改！ (2提示点)",
      "content": "“这段记录似乎……”中有一个词看上去很不自然，它们或许就是玄机所在。"
    },
    {
      "title": "我想不出第三次修改！ (3提示点)",
      "content": "回顾本区剧情，澜夜一直想念的是谁呢？"
    },
    {
      "title": "该如何提取？ (3提示点)",
      "content": "完成三次修改后会得到一段文本，其中暗示了提取方法，你需要将12句引文（注意“句”和“段”的区别）依次排开，再应用这种方法。"
    }
  ],
  "additionalAnswers": [],
  "links": [
    {
      "title": "索引页",
      "type": "index",
      "path": "seco2/index"
    },
    {
      "title": "庄园",
      "path": "/area/seco2/1",
      "pgid": 1
    },
    {
      "title": "沙海",
      "path": "/area/seco2/2",
      "pgid": 2
    },
    {
      "title": "高塔",
      "path": "/area/seco2/3",
      "pgid": 3
    },
    {
      "title": "花原",
      "path": "/area/seco2/4",
      "pgid": 4
    },
    {
      "title": "暗格",
      "path": "/area/seco2/5",
      "pgid": 5
    },
    {
      "title": "过渡",
      "path": "/area/seco2/6",
      "pgid": 6
    },
    {
      "title": "中心",
      "path": "/area/seco2/7",
      "pgid": 7
    },
    {
      "title": "FM",
      "path": "/area/seco2/8",
      "pgid": 8
    }
  ],
  "arealink": {
    "title": "沙海",
    "path": "/area/seco2/2",
    "pgid": 2
  }
}