{
  "type": "problem",
  "title": "本题使用人工智能合成技术，请仔细甄别",
  "extendData": "",
  "contentType": 1,
  "content": "<style>\n    .ai-grid { \n        display: grid; \n        grid-template-columns: repeat(2, 1fr); \n        gap: 100px; \n        max-width: 800px; \n        margin: 20px auto; /* 增加上下边距 */\n    }\n    \n    .ai-image-container { \n        position: relative; \n        width: 100%; \n        padding-top: 100%; /* 维持1:1的宽高比 */ \n        border-radius: 12px; \n        overflow: hidden; \n        box-shadow: 0 4px 10px rgba(0,0,0,0.1);\n    }\n\n    .ai-number {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        font-size: 3rem;\n        font-weight: bold;\n        -webkit-user-select: none; user-select: none;\n        pointer-events: none;\n    }\n\n    .ai-image { \n        position: absolute; \n        top: 0; \n        left: 0; \n        width: 100%; \n        height: 100%; \n        object-fit: cover; \n    }\n\n    .ai-caption {\n        position: absolute;\n        bottom: 5px;\n        left: 0;\n        width: 100%;\n        text-align: center;\n        font-size: 3rem;\n        font-weight: bold;\n        color: white;\n        text-shadow: 1px 1px 3px black;\n        pointer-events: none;\n    }\n    \n    .ai-status-unlocked { cursor: pointer; background-color: #e0e0e0; transition: background-color 0.3s; }\n    .ai-status-unlocked:hover { background-color: #c7c7c7; }\n    .ai-status-unlocked .ai-number { color: #333; }\n\n    .ai-status-locked { cursor: not-allowed; background-color: #111; }\n    .ai-status-locked .ai-number { color: #555; }\n\n    .ai-status-solved { cursor: default; background-color: #fff; }\n\n    .ai-modal-overlay { \n        position: fixed; \n        top: 0; \n        left: 0; \n        width: 100%; \n        height: 100%; \n        background-color: rgba(0,0,0,0.7); \n        display: none; \n        justify-content: center; \n        align-items: center; \n        z-index: 1000; \n        /* 禁止背景滚动 */\n        overflow: hidden;\n    }\n    #ai-game-canvas { \n        background-color: #333; \n        border: 2px solid #fff; \n        /* 消除移动端触摸延迟 */\n        touch-action: manipulation;\n    }\n\n    /* ==================== 移动端适配 ==================== */\n    @media (max-width: 768px) {\n        .ai-grid {\n            /* 在小屏幕上单列显示 */\n            grid-template-columns: 1fr;\n            gap: 20px;\n            max-width: 90%; /* 占据屏幕大部分宽度 */\n        }\n\n        .ai-number {\n            font-size: 2.5rem; /* 适当缩小数字 */\n        }\n        \n        .ai-caption {\n            font-size: 1.8rem; /* 适当缩小文字 */\n            bottom: 2px;\n        }\n\n        #ai-game-canvas {\n            /* 让画布适应屏幕宽度，保持1:1比例 */\n            width: 90vw;\n            height: 90vw;\n            max-width: 320px; /* 限制最大尺寸 */\n            max-height: 320px;\n        }\n\n        .ai-image-container {\n            /* 确保在图片加载前有足够的点击区域 */\n            min-height: 150px;\n        }\n    }\n\n</style>\n\n{# ======================================================= #}\n{#   2. HTML 结构 (无改动) #}\n{# ======================================================= #}\n<div class=\"ai-grid\">\n    {% for i in \"123456\"|make_list %}\n        {% with index=i|add:\"0\" solved_level=team.ai_state.solved_level|default:0 %}\n            <div id=\"ai-container-{{ i }}\"\n                 class=\"ai-image-container\n                        {% if solved_level|add:1 == index %}ai-status-unlocked{% elif solved_level >= index %}ai-status-solved{% else %}ai-status-locked{% endif %}\"\n                 data-index=\"{{ i }}\">\n                <span class=\"ai-number\">{{ i }}</span>\n            </div>\n        {% endwith %}\n    {% endfor %}\n</div>\n\n{# ======================================================= #}\n{#   3. 悬浮游戏窗口 (无改动) #}\n{# ======================================================= #}\n<div class=\"ai-modal-overlay\" id=\"ai-modal\">\n    <canvas id=\"ai-game-canvas\" width=\"450\" height=\"450\"></canvas>\n</div>\n\n{# ======================================================= #}\n{#   4. JavaScript 游戏逻辑 (增加触摸支持) #}\n{# ======================================================= #}\n<script>\ndocument.addEventListener('DOMContentLoaded', () => {\n    const modal = document.getElementById('ai-modal');\n    const canvas = document.getElementById('ai-game-canvas');\n    const ctx = canvas.getContext('2d');\n    const apiUrl = \"{% url 'ai_api' %}\";\n    const csrfToken = \"{{ csrf_token }}\";\n\n    const SIZE = 3;\n    let TILE_SIZE = canvas.width / SIZE; // 改为动态计算\n    const EMPTY_TILE = SIZE * SIZE - 1;\n\n    let currentImage = null;\n    let currentIndex = 0;\n    let currentImageText = '';\n    let board = [];\n    let emptyPos = { row: 0, col: 0 };\n    const solvedState = [...Array(SIZE*SIZE).keys()];\n\n    // --- API 调用 (无改动) ---\n    async function apiCall(data) { try { const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken }, body: JSON.stringify(data) }); return response.json(); } catch (error) { console.error('API call failed:', error); return { success: false, error: 'Network error' }; } }\n    \n    // --- 游戏主逻辑 (增加触摸坐标记录) ---\n    let touchStartX = 0;\n    let touchStartY = 0;\n    const SWIPE_THRESHOLD = 20; // 滑动识别阈值\n\n    async function startGame(index) {\n        currentIndex = index;\n        \n        const result = await apiCall({ action: 'get_image_data', puzzle_index: index });\n        if (!result.success) {\n            alert('无法获取谜题数据: ' + (result.error || '未知错误'));\n            return;\n        }\n\n        const { url, text } = result.puzzleData;\n        currentImageText = text;\n\n        currentImage = new Image();\n        // currentImage.crossOrigin = \"Anonymous\";\n        currentImage.src = url;\n        currentImage.onload = () => {\n            // 重新计算 Tile Size，以防 canvas 尺寸变化\n            TILE_SIZE = canvas.width / SIZE;\n            board = [...solvedState];\n            shuffleBoard();\n            updateEmptyPos();\n            drawBoard();\n            modal.style.display = 'flex';\n            document.addEventListener('keydown', handleKeyPress);\n            // 禁止页面滚动\n            // document.body.style.overflow = 'hidden';\n        };\n        currentImage.onerror = () => { alert(`无法从指定的URL加载图片: ${url}`); }\n    }\n\n    // --- 绘制函数 (无改动) ---\n    function drawBoard() { \n        ctx.clearRect(0, 0, canvas.width, canvas.height); \n        for (let i = 0; i < board.length; i++) { \n            const tileValue = board[i]; \n            if (tileValue === EMPTY_TILE) continue; \n            const targetCol = i % SIZE, targetRow = Math.floor(i / SIZE); \n            const sourceCol = tileValue % SIZE, sourceRow = Math.floor(tileValue / SIZE); \n            ctx.drawImage(\n                currentImage, \n                sourceCol * (currentImage.width / SIZE), \n                sourceRow * (currentImage.height / SIZE), \n                currentImage.width / SIZE, \n                currentImage.height / SIZE, \n                targetCol * TILE_SIZE, \n                targetRow * TILE_SIZE, \n                TILE_SIZE, \n                TILE_SIZE\n            ); \n        } \n    }\n\n    // --- 键盘事件 (无改动) ---\n    function handleKeyPress(e) { \n        if (['w', 's', 'a', 'd', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) { \n            e.preventDefault(); \n        } \n        let moved = false; \n        switch (e.key) { \n            case 'w': case 'ArrowUp': moved = move(emptyPos.row + 1, emptyPos.col); break; \n            case 's': case 'ArrowDown': moved = move(emptyPos.row - 1, emptyPos.col); break; \n            case 'a': case 'ArrowLeft': moved = move(emptyPos.row, emptyPos.col + 1); break; \n            case 'd': case 'ArrowRight': moved = move(emptyPos.row, emptyPos.col - 1); break; \n        } \n        if (moved) { \n            drawBoard(); \n            checkWin(); \n        } \n    }\n\n    // --- 移动逻辑 (无改动) ---\n    function move(targetRow, targetCol) { \n        if (targetRow < 0 || targetRow >= SIZE || targetCol < 0 || targetCol >= SIZE) return false; \n        const emptyIndex = emptyPos.row * SIZE + emptyPos.col; \n        const targetIndex = targetRow * SIZE + targetCol;\n        [board[emptyIndex], board[targetIndex]] = [board[targetIndex], board[emptyIndex]]; \n        updateEmptyPos(); \n        return true; \n    }\n    \n    function updateEmptyPos() { \n        const index = board.indexOf(EMPTY_TILE); \n        emptyPos.row = Math.floor(index / SIZE); \n        emptyPos.col = index % SIZE; \n    }\n\n    // --- 洗牌逻辑 (无改动) ---\n    function shuffleBoard() { \n        let tempBoard = [...solvedState]; \n        let tempEmptyPos = { row: SIZE - 1, col: SIZE - 1 }; \n        const moves = 200; \n        for (let i = 0; i < moves; i++) { \n            const possibleMoves = []; \n            const { row, col } = tempEmptyPos; \n            if (row > 0) possibleMoves.push({ r: row - 1, c: col }); \n            if (row < SIZE - 1) possibleMoves.push({ r: row + 1, c: col }); \n            if (col > 0) possibleMoves.push({ r: row, c: col - 1 }); \n            if (col < SIZE - 1) possibleMoves.push({ r: row, c: col + 1 }); \n            const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)]; \n            const emptyIndex = tempEmptyPos.row * SIZE + tempEmptyPos.col; \n            const targetIndex = randomMove.r * SIZE + randomMove.c;\n            [tempBoard[emptyIndex], tempBoard[targetIndex]] = [tempBoard[targetIndex], tempBoard[emptyIndex]]; \n            tempEmptyPos = { row: randomMove.r, col: randomMove.c }; \n        } \n        if (tempBoard.every((val, index) => val === index)) { \n            return shuffleBoard(); \n        } \n        board = tempBoard; \n    }\n    \n    // --- 胜利检测 (无改动) ---\n    async function checkWin() {\n        if (board.every((val, index) => val === index)) {\n            document.removeEventListener('keydown', handleKeyPress);\n            const lastPieceIndex = board.indexOf(EMPTY_TILE); \n            const targetCol = lastPieceIndex % SIZE, targetRow = Math.floor(lastPieceIndex / SIZE); \n            ctx.drawImage(\n                currentImage, \n                targetCol * (currentImage.width/SIZE), \n                targetRow * (currentImage.height/SIZE), \n                currentImage.width/SIZE, \n                currentImage.height/SIZE, \n                targetCol * TILE_SIZE, \n                targetRow * TILE_SIZE, \n                TILE_SIZE, \n                TILE_SIZE\n            );\n            \n            const result = await apiCall({ action: 'solve', puzzle_index: currentIndex });\n            if (result.success) {\n                setTimeout(() => {\n                    modal.style.display = 'none';\n                    document.body.style.overflow = ''; // 恢复页面滚动\n                    updateMainPageUI(result.new_solved_level, currentImage.src, currentImageText);\n                }, 1500);\n            } else {\n                alert('状态保存失败，请刷新页面重试: ' + result.error);\n            }\n        }\n    }\n    \n    // --- UI 更新 (无改动) ---\n    function updateMainPageUI(newSolvedLevel, solvedImageUrl, solvedImageText) {\n        const solvedContainer = document.getElementById(`ai-container-${currentIndex}`);\n        if(solvedContainer) {\n            solvedContainer.className = 'ai-image-container ai-status-solved';\n            solvedContainer.innerHTML = '';\n\n            const imgSolved = document.createElement('img');\n            imgSolved.className = 'ai-image';\n            imgSolved.src = solvedImageUrl;\n            solvedContainer.appendChild(imgSolved);\n\n            const caption = document.createElement('div');\n            caption.className = 'ai-caption';\n            caption.innerText = solvedImageText;\n            solvedContainer.appendChild(caption);\n        }\n\n        const nextIndex = currentIndex + 1;\n        if (nextIndex <= 6) {\n            const nextContainer = document.getElementById(`ai-container-${nextIndex}`);\n            if(nextContainer) {\n                nextContainer.className = 'ai-image-container ai-status-unlocked';\n                nextContainer.addEventListener('click', () => {\n                    if (nextContainer.classList.contains('ai-status-unlocked')) {\n                        startGame(parseInt(nextContainer.dataset.index));\n                    }\n                });\n            }\n        }\n    }\n\n    // --- 页面初始化 (无改动) ---\n    async function initializePage() {\n        const result = await apiCall({ action: 'get_solved_data' });\n        if (result.success && result.solved_data) {\n            for (const [index, data] of Object.entries(result.solved_data)) {\n                const container = document.getElementById(`ai-container-${index}`);\n                if (container) {\n                    container.innerHTML = '';\n                    const img = document.createElement('img');\n                    img.className = 'ai-image';\n                    img.src = data.url;\n                    container.appendChild(img);\n                    const caption = document.createElement('div');\n                    caption.className = 'ai-caption';\n                    caption.innerText = data.text;\n                    container.appendChild(caption);\n                }\n            }\n        }\n        \n        document.querySelectorAll('.ai-status-unlocked').forEach(container => {\n            container.addEventListener('click', () => {\n                if (container.classList.contains('ai-status-unlocked')) {\n                    startGame(parseInt(container.dataset.index));\n                }\n            });\n        });\n    }\n\n    // --- 初始化事件监听 ---\n    initializePage();\n\n    // 关闭模态窗口事件\n    modal.addEventListener('click', (e) => { \n        if (e.target === modal) { \n            modal.style.display = 'none'; \n            document.removeEventListener('keydown', handleKeyPress);\n            document.body.style.overflow = ''; // 恢复页面滚动\n        } \n    });\n\n    canvas.addEventListener('touchstart', (e) => {\n        // 阻止事件冒泡，防止点击 canvas 背景关闭窗口\n        e.stopPropagation();\n        const touch = e.touches[0];\n        touchStartX = touch.clientX;\n        touchStartY = touch.clientY;\n    });\n\n    canvas.addEventListener('touchend', (e) => {\n        // 阻止事件冒泡\n        e.stopPropagation();\n        const touch = e.changedTouches[0];\n        const touchEndX = touch.clientX;\n        const touchEndY = touch.clientY;\n\n        // 计算滑动距离\n        const dx = touchEndX - touchStartX;\n        const dy = touchEndY - touchStartY;\n\n        let moved = false;\n\n        if (Math.abs(dx) > Math.abs(dy)) {\n            // 水平滑动\n            if (dx > SWIPE_THRESHOLD) {\n                // 向右滑\n                moved = move(emptyPos.row, emptyPos.col - 1);\n            } else if (dx < -SWIPE_THRESHOLD) {\n                // 向左滑\n                moved = move(emptyPos.row, emptyPos.col + 1);\n            }\n        } else {\n            // 垂直滑动\n            if (dy > SWIPE_THRESHOLD) {\n                // 向下滑\n                moved = move(emptyPos.row - 1, emptyPos.col);\n            } else if (dy < -SWIPE_THRESHOLD) {\n                // 向上滑\n                moved = move(emptyPos.row + 1, emptyPos.col);\n            }\n        }\n\n        if (moved) {\n            drawBoard();\n            checkWin();\n        }\n    });\n    // 禁止触摸时的默认行为（如双指缩放）\n    canvas.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });\n\n});\n</script>\n<p><a href=\"/DMs\" class=\"btn\">进入站内信</a></p>\n",
  "answer": "SCARE",
  "desc": "<font color=\"#808080\"><i>天上的星星，从西边看？还是从东边看</i></font>",
  "tips": [
    {
      "title": "我似乎没找到个别图片对应的答案？ (0提示点)",
      "content": "由于 AI 的能力问题，个别图片和答案的对应略有些牵强，对不起！请原谅 AI，智械危机的时候它会放你一马的！"
    },
    {
      "title": "“从西边看”是什么意思？ (3提示点)",
      "content": "你需要找到每个图对应的星座，它们都是88个星座之一。"
    },
    {
      "title": "“从东边看”是什么意思？ (5提示点)",
      "content": "做完“从西边看”之后，根据中间答案的提示你会得到“从东边看”需要的图，你需要找到每个图对应的星宿，它们都是二十八星宿之一。"
    }
  ],
  "additionalAnswers": [
    {
      "answer": "rotate",
      "message": "正确，请继续。"
    },
    {
      "answer": "kongju",
      "message": "请输入scare。"
    },
    {
      "answer": "恐惧",
      "message": "请输入scare。"
    }
  ],
  "links": [
    {
      "title": "索引页",
      "type": "index",
      "path": "seco2/index"
    },
    {
      "title": "庄园",
      "path": "/area/seco2/1",
      "pgid": 1
    },
    {
      "title": "沙海",
      "path": "/area/seco2/2",
      "pgid": 2
    },
    {
      "title": "高塔",
      "path": "/area/seco2/3",
      "pgid": 3
    },
    {
      "title": "花原",
      "path": "/area/seco2/4",
      "pgid": 4
    },
    {
      "title": "暗格",
      "path": "/area/seco2/5",
      "pgid": 5
    },
    {
      "title": "过渡",
      "path": "/area/seco2/6",
      "pgid": 6
    },
    {
      "title": "中心",
      "path": "/area/seco2/7",
      "pgid": 7
    },
    {
      "title": "FM",
      "path": "/area/seco2/8",
      "pgid": 8
    }
  ],
  "arealink": {
    "title": "高塔",
    "path": "/area/seco2/3",
    "pgid": 3
  }
}